//================================================================================
// NES(6502)用 CC65"HELLO WORLD"サンプル
// 2025 By Kanno-Develop
//
// - このコードは、CC65を使用してNES(6502)プログラムをC言語で書くサンプルです。
// - しかし正直なところ、C言語では6502の性能を十分に発揮することは難しいです。
// - そのため処理負荷の軽減や、将来的にアセンブラ化しやすい構造にするために
//   6502のPPU/コントローラレジスタに直接アクセスする書き方をしています。
//
//--------------------------------------------------------------------------------
// ◆レジスタとは何か？（このコードでの意味）
//--------------------------------------------------------------------------------
// - 6502には「A, X, Y」などのCPU内部レジスタがありますが、
//   ここでいうレジスタは「メモリマップされたI/Oポート」のことを指します。
//
// - NESのPPU（Picture Processing Unit）やコントローラ、サウンド等は
//   特定のメモリアドレスにアクセスすることで操作・状態取得ができます。
//   例:
//     アドレス $2000 → PPU制御レジスタ1
//     アドレス $2001 → PPU制御レジスタ2
//
// - このアドレスに対して「*ポインタ = 値;」のように書き込むと、
//   ハードウェアが直接反応します。
//   例: PPUの初期化(VBlank発生時にNMIProcが呼ばれるようにし、背景表示をONにする)
//     *(UChar*)0x2000 = 0x80;
//     *(UChar*)0x2001 = 0x08;
//
// - 普通の変数や配列とは違い、これらは「RAM上のデータ」ではなく
//   「ハードに直結したスイッチやセンサー」だと考えると理解しやすいです。
//================================================================================


//--------------------------------------------------------------
// 変数型の定義
//--------------------------------------------------------------
// 基本的には一番軽いUCharを使用します。
typedef unsigned char   UChar;		// 1バイト符号なし (0〜255)
typedef signed char     SChar;		// 1バイト符号付き (-128〜127)
typedef unsigned short  UShort;		// 2バイト符号なし (0〜65535)
typedef signed short    SShort;		// 2バイト符号付き (-32768〜32767)


//--------------------------------------------------------------
// レジスタ定義
//--------------------------------------------------------------
// NESのPPUやコントローラは特定のメモリアドレスで操作します。
// ここでは、そのアドレスに対応したポインタを定義しています。
// これを使ってC言語からハードウェアを直接操作します。
#define REGIST_PPU_CTRL1          (UChar*)0x2000	// 制御レジスタ1
#define REGIST_PPU_CTRL2          (UChar*)0x2001	// 制御レジスタ2
#define REGIST_PPU_STS            (UChar*)0x2002	// ステータスレジスタ
#define REGIST_SCROLL             (UChar*)0x2005	// スクロールレジスタ
#define REGIST_ADR                (UChar*)0x2006	// VRAMアドレスレジスタ
#define REGIST_GRA                (UChar*)0x2007	// VRAMアクセスレジスタ
#define REGIST_PAD                (UChar*)0x4016	// コントローラ入力レジスタ


//--------------------------------------------------------------
// コントローラボタン定義
//--------------------------------------------------------------
// 各ビットが特定ボタンを表します。
#define BUTTON_A        0x80	// Aボタン
#define BUTTON_B        0x40	// Bボタン
#define BUTTON_SELECT   0x20	// セレクトボタン
#define BUTTON_START    0x10	// スタートボタン
#define BUTTON_UP       0x08	// 十字ボタン　上
#define BUTTON_DOWN     0x04	// 十字ボタン　下
#define BUTTON_LEFT     0x02	// 十字ボタン　左
#define BUTTON_RIGHT    0x01	// 十字ボタン　右


//--------------------------------------------------------------
// パッド番号（0=1P, 1=2P）
//--------------------------------------------------------------
#define PAD_NO 0

//--------------------------------------------------------------
// 表示するテキスト
//--------------------------------------------------------------
const UChar text[] = "HELLO WORLD";

//--------------------------------------------------------------
// グローバル変数
//--------------------------------------------------------------
// VBlank中フラグ: 1フレームの描画完了を検出する
static UChar s_vblank_flag = 0;	

// スクロール位置（背景スクロール用）
static UChar s_scrollX = 0;
static UChar s_scrollY = 0;


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// NMI割り込みハンドラ
// - NESの6502では、画面描画が終わるVBlankの開始時にNMI割り込みが発生します。
// - この関数はその割り込みで呼ばれ、1秒間に約60回実行されます。
// - VBlank中はVRAMを安全に更新できる唯一のタイミングです。
// - 処理時間は非常に短いため、なるべく軽い処理を心がけてください。
// - 処理が重すぎると描画が乱れる原因になります。
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NMIProc(void)
{
	// スクロールレジスタの設定
	// 先にPPU制御レジスタ1を明示的に設定します。
	*REGIST_PPU_CTRL1 = 0x80;

	// スクロール位置（X,Y）を設定
	// NESのスクロール値はX(0〜255),Y(0～239)なので、X,Yを別々に送ります。
	// 
	// ※なお、このプログラムではYの値は0～255の範囲を使用しており、
	// 　はみ出た部分のチェックをしていない為、その場合は画面が乱れる可能性があります。
	*REGIST_SCROLL = s_scrollX;
	*REGIST_SCROLL = s_scrollY;

	// vblankフラグを立てる
	s_vblank_flag = 1;
}


//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// メイン処理
// - NES起動後に最初に呼ばれる関数（エントリポイント）
// - 初期化 → メインループ（コントローラ入力取得 → スクロール更新 → VBlank待ち）の繰り返し
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void NesMain()
{
	UChar i;         // ループ用カウンタ
	UChar pad;       // 1回の読み取りで取得するボタンビット
	UChar inputTemp; // コントローラのボタン状態をまとめて格納

	//----------------------------------------------------------
	// 初期化
	//----------------------------------------------------------
	// VBlankフラグをクリア
	s_vblank_flag = 0;

	// PPUを描画OFF状態に設定
	*REGIST_PPU_CTRL1 = 0x00;
    *REGIST_PPU_CTRL2 = 0x00;


	//----------------------------------------------------------
	// BG面に "HELLO WORLD" を描画
	//----------------------------------------------------------
	// NESの背景画面は32x30タイルで構成されています。
	// VRAMの書き込み位置は0x2000〜0x23FFの範囲にあります。
	// 座標(x,y)のVRAMアドレスは以下のように計算します。
	//
	//     addr = 0x2000 + (y << 5) + x;
	//
	// VRAM書き込みのカーソルはPPUの0x2006レジスタで設定します。
	// 上位8ビットを1回書き込み、次に下位8ビットを1回書き込みます。
	//
	// *REGIST_ADR = (addr >> 8) & 0xFF;  // 0x2006の上位アドレス設定
	// *REGIST_ADR = addr & 0xFF;         // 0x2006の下位アドレス設定
	//
	// ※今回は座標(10,10)に相当する直値0x214aを直接指定しています。
	//
	*REGIST_ADR = 0x21;  // 上位8ビット
	*REGIST_ADR = 0x4a;  // 下位8ビット


	// テキストデータを順にVRAMへ書き込み
	// VRAMの書き込みポートは$2007（REGIST_GRA）です。
	// ここで1バイトずつ書き込むと、書き込み先のVRAMアドレスが自動的に次に進みます。
	// そのため、ループで連続して書き込むことで文字やタイルを連続配置できます。
	//
	// ※ここでの「文字」は、背景タイル番号としてのコードです。
	//   NESのフォントやグラフィックはタイルセットで構成されており、
	//   この配列の値は対応するタイル番号を示しています。
	//
	for (i = 0; i < sizeof(text); i++)
	{
		*REGIST_GRA = text[i];  // 1文字ずつVRAMへ書き込み
	}
	

	// VBlank待ち
	// PPUのステータスレジスタ($2002)の7ビット目(VBlankフラグ)が1になるまでループ
	// VBlankとは画面描画が終わり次のフレーム準備ができているタイミングのことです
	while (! (*REGIST_PPU_STS & 0x80) );


	// PPUの初期化（描画ON）
	// PPU制御レジスタ1（$2000）のビット構成：
	// ビット番号  内容
	// 7          VBlank時にNMI割込の発生(0=オフ, 1=オン)
	// 6          PPUの選択(0=マスター, 1=スレーブ)
	// 5          スプライトサイズ(0=8x8, 1=8x16)
	// 4          BG用CHRテーブル(0=$0000, 1=$1000)
	// 3          スプライト用CHRテーブル(0=$0000, 1=$1000)
	// 2          VRAM入出力時のアドレス変化(0=+1, 1=+32)
	// 1-0        メインスクリーン(0=$2000, 1=$2400, 2=$2800, 3=$2C00)
	//
	// 例：0x80 = 1000 0000b は
	// ビット7が1なので、VBlank開始時にNMI割込みを有効にし、それ以外はオフの設定です。
	*REGIST_PPU_CTRL1 = 0x80;

	// PPU制御レジスタ2（$2001）のビット構成：
	// ビット番号  内容
	// 7          赤色を強調(0=OFF, 1=ON)
	// 6          緑色を強調(0=OFF, 1=ON)
	// 5          青色を強調(0=OFF, 1=ON)
	// 4          スプライトの表示(0=OFF, 1=ON)
	// 3          背景（BG）の表示(0=OFF, 1=ON)
	// 2          画面左端8ドットのスプライト(0=非表示, 1=表示)
	// 1          画面左端8ドットの背景(0=非表示, 1=表示)
	// 0          色設定(0=カラー, 1=モノクロ)
	//
	// 例：0x0e = 0000 1000b はビット3がセットされているので、
	// 背景を表示するようにしています。
    *REGIST_PPU_CTRL2 = 0x08;


	//----------------------------------------------------------
	// メインループ（1フレームごとの処理）
	//----------------------------------------------------------
	while (1)
	{
		//------------------------------------------------------
		// コントローラ入力取得
		//------------------------------------------------------
		inputTemp = 0;

		// コントローラのボタン状態を取得する処理
		// NESのコントローラはシフトレジスタ方式で動作しており、
		// まずREGIST_PAD($4016)に1を書き込むとコントローラに入力をポーリングするよう信号が送られます。
		// 続いて0を書き込むことで信号を止め、ボタン状態を固定します。
		// その後、8回読み出しを行ない、各ビットがボタンの状態（押されているか）を示します。
		// ボタンは上位から順に読み出され、1ビットずつシフトしてinputTempに格納します。
		*REGIST_PAD = 1;	// 信号ON
		*REGIST_PAD = 0;	// 信号OFF(1 → 0 でボタン状態が固定される)
		for(i=0; i < 8; i++) {
			// REGIST_PAD($4016)を順番に読み取る
			// 読み取る順番に対してそれぞれのボタン状態が取得できる
			// (i==0) Aボタン
			// (i==1) Bボタン
			// (i==2) セレクトボタン
			// (i==3) スタートボタン
			// (i==4) 上ボタン
			// (i==5) 下ボタン
			// (i==6) 左ボタン
			// (i==7) 右ボタン
			pad = *(REGIST_PAD + PAD_NO);

			// 各ビットをinputTempにシフトして格納する
			inputTemp <<= 1;
			inputTemp += (pad & 0x01);
		}

		//------------------------------------------------------
		// スクロール更新
		//------------------------------------------------------
		// 左入力
		if(inputTemp & BUTTON_LEFT)
		{
			s_scrollX--;
		}
		// 右入力
		if(inputTemp & BUTTON_RIGHT)
		{
			s_scrollX++;
		}
		// 上入力
		if(inputTemp & BUTTON_UP)
		{
			s_scrollY--;
		}
		// 下入力
		if(inputTemp & BUTTON_DOWN)
		{
			s_scrollY++;
		}

		//------------------------------------------------------
		// VBlank待ち (NMI割り込み待ち)
		//------------------------------------------------------
		// NMI割り込みでs_vblank_flagが立つまで待機します。
		// ※直接PPUステータスレジスタ（REGIST_PPU_STS）のビット7を読み取る方法もありますが、
		// 　PPUステータスの読み取りはVRAMアドレスのリセットなど副作用があるため、
		// 　本コードではNMI割り込みフラグを使った待機方法を採用しています。
		while(!s_vblank_flag);
		s_vblank_flag = 0;
	};
}
